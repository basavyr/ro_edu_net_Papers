___ 
The original conclusions
____

In the present work, a detailed overview of the XRootD framework was given, together with its major importance within the WLCG group and the High Energy Physics community. A short description of the architecture for both the server-side as well as the client-side was discussed. The asynchronous behavior of the XrdCl API which is written in C++ has been reviewed, with the latest features and release. Furthermore, a special focus was given on the File and FileSystem objects within the XRootD client. The asynchronous APIâ€™s importance in terms of usage has been mentioned and also the drawbacks in terms of code complexity. Subsequently, a discussion was made on the Declarative API, which is built on top of the existing XrdCl asynchronous API, with its main feature being the ease of use from a code-logistic standpoint. The Declarative API was adopted in the implementation of an Erasure Coding plug-in inside the XRootD client. It is showed that Declarative API is an efficient tool in providing an asynchronous C++ interface for the user while keeping a clear and concise workflow.


___ 
revised conclusions
____


* core ideas to be implemented and highlighted
___
1. erasure coding helps with data access in case of failures across the storage compute nodes
	* emphasize the importance of having great backup paradigm within the LHC
	* xrootd serves data/ offers access to the data even if parts of the storage facilities have malfunctions -> motivation
2. having erasure coding implemented as a tool in xrootd is a great functionality for the end-users but also for the admin team that deal with storage traffic. -> purpose
3. implementing a "good" erasure coding procedure requires an async behavior for the plugin mechanism. the parallel approach of writing files and updating any metadata to the existing files is a must -> purpose
4. problem with the current async API is that the workflow in terms of code complexity/readability and repeatability is what one would call "non-efficient". -> motivation
5. that's why the declarative api comes to the rescue, dealing with a much more clearer and concise structure for developing a parallel pipeline that deals with writing data to a remote storage block -> purpose

GOAL

create erasure coding for having a good backup tool, and optimized way of maintaining data access to the users. 

PURPOSE/motivation

erasure coding proves to be a great and efficient tool at keeping a backup but also do not waste that much disk space

ACHIEVEMENTS

we developed the EC plugin using the declarative api, which proves to be a much more concise tool in terms of coding process that the standard async api in c++


